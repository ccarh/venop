
<script>
// vim: ts=3:nowrap:ft=javascript



//////////////////////////////
//
// storeData --
//

function storeData(obj, sheet, json) {
	obj[sheet] = json;
	if ((typeof obj.sheet1 !== "undefined") &&
	    (typeof obj.sheet2 !== "undefined") &&
	    (typeof obj.sheet3 !== "undefined")) {
		obj.loadTime2 = performance.now();
		obj.loadDuration = obj.loadTime2 - obj.loadTime1;
		console.log("VENOP", obj);
		mergeContents(obj, "data", ["sheet1", "sheet2", "sheet3"]);
		obj.dataArray = [];
		for (const property in obj.data) {
			let element = obj.data[property];
			obj.dataArray.push(element);
		}
		obj.results = obj.dataArray;
		displaySearchFields(obj.results, "#search-fields");
		displaySearchResults(obj.results, "#search-results");
	}
}



//////////////////////////////
//
// mergeContents -- Merge contents of separate spreadsheets into a single
//   database indexed by the "Key" field common to all worksheets.
//

function mergeContents(obj, target, sheets) {
	obj[target] = {};
	for (let i=0; i<sheets.length; i++) {
		let source = sheets[i];
		for (let j=0; j<obj[source].length; j++) {
			let key = obj[source][j].Key;
			if (typeof key === "undefined") {
				console.error("Cannot find Key parameter in", obj[source][j]);
				continue;
			}
			if (typeof obj[target][key] === "undefined") {
				obj[target][key] = {};
			}
			for (const property in obj[source][j]) {
				value = obj[source][j].property;
				if (typeof obj[target][key][property] !== "undefined") {
					if (value !== obj[target][key][property]) {
						// console.warn(`FOR KEY >>${key}<< CONTENT DIFFERS FOR PROPERTY >>${source}<<, " WHICH IS NOW >>${value}<< BUT WAS >>${obj[target][key][property]}<<`);
					}
				}
				obj[target][key][property] = obj[source][j][property];
			}
		}
	}
}



//////////////////////////////
//
// displaySearchFields -- Show search fields for browse page.
//

function displaySearchFields(data, target) {
	let element = document.querySelector(target);
	if (!target) {
		console.log("CANNOT FIND TARGET", target, "FOR DISPLAYING SEARCH FIELDS");
		return;
	}

	let output = "";
	output += buildTextSearch("Work title");
	output += buildSelect(data, "Composer");
	output += buildSelect(data, "Librettist");
	output += buildSelect(data, "Theater");
	
	element.innerHTML = output;
}



//////////////////////////////
//
// buildSelectPerson -- Create select menu for persons.  These fields
//    can contain parenthetical content such as "(attrib.) as well as
//    multiple people in one entry.  When there are multiple people or
//    other complications, the name is enclosed in curly brackets so that
//    they can be extracted as separate entities for the select menu.
//

function buildSelectPerson(data, source) {
	let holder = {};
	for (let i=0; i<data.length; i++) {
		let d = data[i][source];
		d = d.replace(/\(.*?\)/g, "");
		d = d.replace(/\[.*?\]/g, "");
		d = d.replace(/,? et al\.?/g, "");
		d = d.replace(/\?/g, "");
		d = d.replace(/^\s+/, "");
		d = d.replace(/\s+$/, "");
		let matches = d.match(/\{(.*?)\}/g);
		if (matches) {
			for (let j=0; j<matches.length; j++) {
				let value = matches[j];
				value = value.replace(/[{}]/g, "");
				if (typeof holder[value] === "undefined") {
					holder[value] = 1;
				} else {
					holder[value]++;
				}
			}
		} else {
			if (typeof holder[d] === "undefined") {
				holder[d] = 1;
			} else {
				holder[d]++;
			}
		}
	}

	let keys = Object.keys(holder).sort();
	
	let output = "";
	output += `<select onchange="doSearch()" data-field="${source}">\n`;
	output += `<option value="">${source}</option>\n`;
	for (let i=0; i<keys.length; i++) {
		output+= `<option value="${keys[i]}">${keys[i]} (${holder[keys[i]]})</option>\n`;
	}
	output += "</select>\n";

	return output;
}




//////////////////////////////
//
// buildSelect --
//

function buildSelect(data, source) {
	if (source == "Composer") {
		return buildSelectPerson(data, source);
	}
	if (source == "Librettist") {
		return buildSelectPerson(data, source);
	}

	let holder = {};
	for (let i=0; i<data.length; i++) {
		let value = data[i][source];
		if (typeof holder[value] === "undefined") {
			holder[value] = 1;
		} else {
			holder[value]++;
		}
	}

	let keys = Object.keys(holder).sort();
	
	let output = "";
	output += `<select onchange="doSearch()" data-field="${source}">\n`;
	output += `<option value="">${source}</option>\n`;
	for (let i=0; i<keys.length; i++) {
		output+= `<option value="${keys[i]}">${keys[i]} (${holder[keys[i]]})</option>\n`;
	}
	output += "</select>\n";

	return output;
}



//////////////////////////////
//
// buildTextSearch --
//

function buildTextSearch(source) {
	let output = `<input spellcheck="false" autocomplete="off" autocorrect="off" tyle="text" oninput="doSearch()" placeholder="${source}" data-field="${source}">`;
	return output;
}



//////////////////////////////
//
// displaySearchResults -- 
//

function displaySearchResults(results, target) {
	displayEntryCount(results.length, "#search-count");

	let element = document.querySelector(target);
	if (!element) {
		return;
	}

	let output = "";
	output += "<table>";
	output += "<tr>";
	output += "<th>Key</th>";
	output += "<th>Sorting date</th>";
	output += "<th>Work title</th>";
	output += "<th>Composer</th>";
	output += "<th>Librettist</th>";
	output += "<th>Theater</th>";
	output += "</tr>";

	for (let i=0; i<results.length; i++) {
		output += "<tr>";
		output += `<td>${results[i]["Key"]}</td>`;
		output += `<td class="nobreak">${results[i]["Sorting date"]}</td>`;
		output += `<td>${results[i]["Work title"]}</td>`;
		output += `<td>${removeCurly(results[i]["Composer"])}</td>`;
		output += `<td>${removeCurly(results[i]["Librettist"])}</td>`;
		output += `<td class="nobreak">${results[i]["Theater"]}</td>`;
		output += "</tr>";
	}

	output += "</table>";
	element.innerHTML = output;

}



//////////////////////////////
//
// removeCurly
//

function removeCurly(string) {
	return string.replace(/[{}]/g, "");
}



//////////////////////////////
//
// doSearch --
//

function doSearch() {
	let selects = document.querySelectorAll("#search-fields select");
	let inputs = document.querySelectorAll("#search-fields input");
	let results = VENOP.dataArray;

	for (let i=0; i<selects.length; i++) {
		let field = selects[i].dataset.field;
		let query = selects[i].value;
		results = filterResults(results, field, query);
	}
	for (let i=0; i<inputs.length; i++) {
		let field = inputs[i].dataset.field;
		let query = inputs[i].value;
		results = filterResults(results, field, query);
	}

	displaySearchResults(results, "#search-results");
	VENOP.results = results;
}



//////////////////////////////
//
// filterResults --
//

function filterResults(input, field, query) {
	if (query === "") {
		return input;
	}
	var queryPieces = "";
	if (field === "Work title") {
		queryPieces = splitQueryIntoPieces(query);
	}

	let output = [];
	for (let i=0; i<input.length; i++) {
		if (field === "Composer") {
			if (input[i][field].match(query)) {
				output.push(input[i]);
			}
		} else if (field === "Librettist") {
			if (input[i][field].match(query)) {
				output.push(input[i]);
			}
		} else if (field === "Dedicatee") {
			if (input[i][field].match(query)) {
				output.push(input[i]);
			}
		} else if (field === "Work title") {
			if (freeTextSearch(input[i][field], queryPieces)) {
				output.push(input[i]);
			}
		} else {
			if (input[i][field] === query) {
				output.push(input[i]);
			}
		}
	}
	return output;
}



//////////////////////////////
//
// freeTextSearch --
//

function freeTextSearch(string, queryArray) {
	string = string.toLowerCase();
	for (let i=0; i<queryArray.length; i++) {
		if (queryArray[i] === "") {
			continue;
		}
		if (!string.match(queryArray[i])) {
			return false;
		}
	}
	return true;
}



//////////////////////////////
//
// splitQueryIntoPieces == used to allow multiple word searching in titles.
//    returns an array of the search queryies.
// 

function splitQueryIntoPieces(input) {
	if (!input) {
		return [""];
	}
	if (typeof input !== "string") {
		return [""];
	}

	input = input.toLowerCase();

	let output = [];
	let current = "";

	let inQuote = false;
	for (let i=0; i<input.length; i++) {
		if (input[i] === '"') {
			if ((i>0) && (input[i-1] == "\\")) {
				// regular double quote.
				current += '"';
				continue;
			} else {
				if (inQuote) {
					if (current.length > 0) {
						output.push(current);
						current = "";
					}
				} else {
					if (current.length > 0) {
						output.push(current);
						current = "";
					}
				}
				inQuote = !inQuote;
				continue;
			}
		} else if (/\s/.test(input[i])) {
			// white space, so switch to a new word
			if (current.length) {
				output.push(current);
				current = "";
			}
		} else {
			// add character to current word
			current += input[i];
		}
	}
	if (current.length) {
		output.push(current);
	}
	return output;
}



//////////////////////////////
//
// displayEntryCount --
//

function displayEntryCount(count, target) {
	let element = document.querySelector(target);
	if (!element) {
		return;
	}
	let output = count;
	if (count == 1) {
		output += " entry";
	} else{
		output += " entries";
	}
	element.innerHTML = output;
}


</script>



